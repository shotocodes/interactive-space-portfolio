<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Three.js 半透明球体 + 粒子エフェクト - Enhanced</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: radial-gradient(circle at center, #0a0a0a 0%, #000000 100%);
      overflow: hidden;
      font-family: 'Arial', sans-serif;
    }

    #container {
      width: 100vw;
      height: 100vh;
      position: relative;
    }

    #controls {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 100;
      color: white;
      background: rgba(15, 15, 30, 0.8);
      padding: 20px;
      border-radius: 15px;
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    .control-group {
      margin-bottom: 15px;
    }

    label {
      display: block;
      margin-bottom: 8px;
      font-size: 13px;
      color: #e0e0e0;
      font-weight: 500;
    }

    input[type="range"] {
      width: 160px;
      height: 6px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
      outline: none;
      -webkit-appearance: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      background: linear-gradient(45deg, #667eea 0%, #764ba2 100%);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
    }

    .button-group {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    button {
      background: linear-gradient(45deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 10px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 11px;
      font-weight: 600;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
    }

    button.active {
      background: linear-gradient(45deg, #ff6b6b 0%, #ee5a24 100%);
      box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
    }

    #info {
      position: absolute;
      bottom: 20px;
      left: 20px;
      color: white;
      font-size: 11px;
      background: rgba(15, 15, 30, 0.8);
      padding: 15px;
      border-radius: 10px;
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .value {
      color: #667eea;
      font-weight: bold;
    }

    #title {
      position: absolute;
      top: 30%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      color: white;
      z-index: 50;
      pointer-events: none;
      opacity: 0;
      animation: fadeIn 3s ease-in-out 1s forwards;
    }

    #title h1 {
      font-size: 2.5rem;
      margin-bottom: 0.5rem;
      text-shadow: 0 0 20px rgba(102, 126, 234, 0.6);
    }

    #title p {
      font-size: 1rem;
      opacity: 0.8;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translate(-50%, -50%) translateY(20px);
      }

      to {
        opacity: 1;
        transform: translate(-50%, -50%) translateY(0);
      }
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="title">
      <h1>Interactive 3D Experience</h1>
      <p>Three.js Portfolio Demo</p>
    </div>

    <div id="controls">
      <div class="control-group">
        <label>粒子数: <span class="value" id="particleCountValue">3000</span></label>
        <input type="range" id="particleCount" min="500" max="6000" value="3000" step="500">
      </div>
      <div class="control-group">
        <label>球体サイズ: <span class="value" id="sphereSizeValue">3</span></label>
        <input type="range" id="sphereSize" min="1" max="8" value="3" step="0.5">
      </div>
      <div class="control-group">
        <label>粒子距離: <span class="value" id="particleDistanceValue">0.5</span></label>
        <input type="range" id="particleDistance" min="0.1" max="2" value="0.5" step="0.1">
      </div>
      <div class="control-group">
        <label>球体透明度: <span class="value" id="sphereOpacityValue">0.3</span></label>
        <input type="range" id="sphereOpacity" min="0" max="1" value="0.3" step="0.1">
      </div>
      <div class="control-group">
        <label>回転速度: <span class="value" id="rotationSpeedValue">0.008</span></label>
        <input type="range" id="rotationSpeed" min="0" max="0.03" value="0.008" step="0.002">
      </div>

      <div class="button-group">
        <button onclick="toggleAnimation()">⏸️ Pause/Play</button>
        <button onclick="randomizeColors()">🎨 Random Colors</button>
        <button onclick="explodeSphere()" id="explodeBtn">💥 Explode</button>
        <button onclick="resetView()">🔄 Reset View</button>
        <button onclick="toggleWarpMode()" id="warpBtn">🌀 Warp Mode</button>
        <button onclick="toggleMagneticMode()" id="magneticBtn">🧲 Magnetic</button>
      </div>
    </div>

    <div id="info">
      <strong>操作方法:</strong><br>
      マウスドラッグ: 回転 | ホイール: ズーム | スペース: 爆発<br>
      粒子数: <span class="value" id="currentParticleCount">3000</span> |
      FPS: <span class="value" id="fps">60</span>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    let scene, camera, renderer, particles, sphereMesh, geometry, material, sphereGeometry, sphereMaterial;
    let isAnimating = true;
    let rotationSpeed = 0.008;
    let sphereRadius = 3;
    let particleCount = 3000;
    let particleDistance = 0.5;
    let sphereOpacity = 0.3;

    // 新機能用変数
    let warpMode = false;
    let magneticMode = false;
    let mouseNormalizedX = 0;
    let mouseNormalizedY = 0;

    // 爆発エフェクト用変数
    let isExploding = false;
    let explosionParticles = [];
    let explosionProgress = 0;
    let explosionDuration = 3000;
    let explosionStartTime = 0;

    // マウス制御用変数
    let mouseX = 0, mouseY = 0;
    let isMouseDown = false;
    let cameraDistance = 12;
    let cameraAngleX = 0, cameraAngleY = 0;

    // パフォーマンス測定
    let frameCount = 0;
    let lastTime = performance.now();
    let time = 0;

    function init() {
      scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x000000, 10, 50);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 0, cameraDistance);

      renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x000000, 1);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.getElementById('container').appendChild(renderer.domElement);

      setupLighting();
      createSphere();
      createParticleSystem();
      setupEventListeners();
      animate();
    }

    function setupLighting() {
      const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
      scene.add(ambientLight);

      const pointLight = new THREE.PointLight(0x667eea, 1, 100);
      pointLight.position.set(10, 10, 10);
      pointLight.castShadow = true;
      scene.add(pointLight);

      const pointLight2 = new THREE.PointLight(0x764ba2, 0.8, 100);
      pointLight2.position.set(-10, -10, 10);
      scene.add(pointLight2);
    }

    function createSphere() {
      if (sphereMesh) {
        scene.remove(sphereMesh);
        sphereGeometry.dispose();
        sphereMaterial.dispose();
      }

      sphereGeometry = new THREE.SphereGeometry(sphereRadius, 64, 64);
      sphereMaterial = new THREE.MeshPhongMaterial({
        color: 0x667eea,
        transparent: true,
        opacity: sphereOpacity,
        shininess: 100,
        specular: 0x222222,
        side: THREE.DoubleSide
      });

      sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
      sphereMesh.receiveShadow = true;
      scene.add(sphereMesh);
    }

    function createParticleSystem() {
      if (particles) {
        scene.remove(particles);
        geometry.dispose();
        material.dispose();
      }

      geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);
      const sizes = new Float32Array(particleCount);

      for (let i = 0; i < particleCount; i++) {
        const phi = Math.acos(-1 + (2 * i) / particleCount);
        const theta = Math.sqrt(particleCount * Math.PI) * phi;
        const radius = sphereRadius + particleDistance + Math.random() * particleDistance;

        const x = radius * Math.cos(theta) * Math.sin(phi);
        const y = radius * Math.cos(phi);
        const z = radius * Math.sin(theta) * Math.sin(phi);

        positions[i * 3] = x;
        positions[i * 3 + 1] = y;
        positions[i * 3 + 2] = z;

        const color = new THREE.Color();
        const hue = (i / particleCount) * 0.6 + 0.15;
        const saturation = 0.8;
        const lightness = 0.5 + Math.random() * 0.3;
        color.setHSL(hue, saturation, lightness);

        colors[i * 3] = color.r;
        colors[i * 3 + 1] = color.g;
        colors[i * 3 + 2] = color.b;

        sizes[i] = 0.02 + Math.random() * 0.08;
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

      // 新機能対応シェーダー
      material = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          mousePos: { value: new THREE.Vector2(0, 0) },
          warpMode: { value: 0 },
          magneticMode: { value: 0 }
        },
        vertexShader: `
                    attribute float size;
                    attribute vec3 color;
                    varying vec3 vColor;
                    uniform float time;
                    uniform vec2 mousePos;
                    uniform float warpMode;
                    uniform float magneticMode;

                    void main() {
                        vColor = color;
                        vec3 pos = position;

                        // 基本の揺れ
                        pos += sin(time + position.x * 0.01) * 0.01;

                        // ワープモード
                        if (warpMode > 0.0) {
                            float warpStrength = warpMode * 0.5;
                            pos.x += sin(time * 2.0 + pos.y * 0.5) * warpStrength;
                            pos.y += cos(time * 1.5 + pos.z * 0.3) * warpStrength;
                            pos.z += sin(time * 1.8 + pos.x * 0.4) * warpStrength;
                        }

                        // マグネティックモード
                        if (magneticMode > 0.0) {
                            vec3 mousePos3D = vec3(mousePos * 8.0, 0.0);
                            vec3 toMouse = mousePos3D - pos;
                            float distance = length(toMouse);
                            if (distance < 10.0) {
                                float pull = (10.0 - distance) / 10.0;
                                pos += normalize(toMouse) * pull * magneticMode * 0.8;
                            }
                        }

                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        gl_PointSize = size * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
        fragmentShader: `
                    varying vec3 vColor;

                    void main() {
                        vec2 center = gl_PointCoord - 0.5;
                        float r = length(center);

                        if (r > 0.5) discard;

                        float alpha = 1.0 - smoothstep(0.0, 0.5, r);
                        gl_FragColor = vec4(vColor, alpha * 0.8);
                    }
                `,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthTest: false
      });

      particles = new THREE.Points(geometry, material);
      scene.add(particles);
      document.getElementById('currentParticleCount').textContent = particleCount;
    }

    function setupEventListeners() {
      window.addEventListener('resize', onWindowResize);

      // マウス追跡
      document.addEventListener('mousemove', (e) => {
        mouseNormalizedX = (e.clientX / window.innerWidth) * 2 - 1;
        mouseNormalizedY = -(e.clientY / window.innerHeight) * 2 + 1;
      });

      renderer.domElement.addEventListener('mousedown', onMouseDown);
      renderer.domElement.addEventListener('mousemove', onMouseMove);
      renderer.domElement.addEventListener('mouseup', onMouseUp);
      renderer.domElement.addEventListener('wheel', onMouseWheel);

      // キーボードイベント
      document.addEventListener('keydown', (e) => {
        if (e.code === 'Space') {
          e.preventDefault();
          explodeSphere();
        }
      });

      // コントロール
      document.getElementById('particleCount').addEventListener('input', (e) => {
        particleCount = parseInt(e.target.value);
        document.getElementById('particleCountValue').textContent = particleCount;
        createParticleSystem();
      });

      document.getElementById('sphereSize').addEventListener('input', (e) => {
        sphereRadius = parseFloat(e.target.value);
        document.getElementById('sphereSizeValue').textContent = sphereRadius;
        createSphere();
        createParticleSystem();
      });

      document.getElementById('particleDistance').addEventListener('input', (e) => {
        particleDistance = parseFloat(e.target.value);
        document.getElementById('particleDistanceValue').textContent = particleDistance;
        createParticleSystem();
      });

      document.getElementById('sphereOpacity').addEventListener('input', (e) => {
        sphereOpacity = parseFloat(e.target.value);
        document.getElementById('sphereOpacityValue').textContent = sphereOpacity;
        if (sphereMaterial) {
          sphereMaterial.opacity = sphereOpacity;
        }
      });

      document.getElementById('rotationSpeed').addEventListener('input', (e) => {
        rotationSpeed = parseFloat(e.target.value);
        document.getElementById('rotationSpeedValue').textContent = rotationSpeed;
      });
    }

    // 新機能関数
    function toggleWarpMode() {
      warpMode = !warpMode;
      const btn = document.getElementById('warpBtn');
      btn.classList.toggle('active', warpMode);
      btn.textContent = warpMode ? '🌀 Warp ON' : '🌀 Warp Mode';
    }

    function toggleMagneticMode() {
      magneticMode = !magneticMode;
      const btn = document.getElementById('magneticBtn');
      btn.classList.toggle('active', magneticMode);
      btn.textContent = magneticMode ? '🧲 Magnetic ON' : '🧲 Magnetic';
    }

    // 既存関数（省略版）
    function onMouseDown(event) {
      isMouseDown = true;
      mouseX = event.clientX;
      mouseY = event.clientY;
    }

    function onMouseMove(event) {
      if (isMouseDown) {
        const deltaX = event.clientX - mouseX;
        const deltaY = event.clientY - mouseY;
        cameraAngleY += deltaX * 0.008;
        cameraAngleX += deltaY * 0.008;
        cameraAngleX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraAngleX));
        updateCameraPosition();
        mouseX = event.clientX;
        mouseY = event.clientY;
      }
    }

    function onMouseUp() { isMouseDown = false; }

    function onMouseWheel(event) {
      cameraDistance += event.deltaY * 0.01;
      cameraDistance = Math.max(5, Math.min(50, cameraDistance));
      updateCameraPosition();
    }

    function updateCameraPosition() {
      camera.position.x = cameraDistance * Math.sin(cameraAngleY) * Math.cos(cameraAngleX);
      camera.position.y = cameraDistance * Math.sin(cameraAngleX);
      camera.position.z = cameraDistance * Math.cos(cameraAngleY) * Math.cos(cameraAngleX);
      camera.lookAt(0, 0, 0);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      time += 0.016;

      if (isExploding) {
        updateExplosion();
      } else if (isAnimating) {
        if (particles) {
          particles.rotation.y += rotationSpeed;
          particles.rotation.x += rotationSpeed * 0.3;
        }
        if (sphereMesh) {
          sphereMesh.rotation.y += rotationSpeed * 0.5;
          sphereMesh.rotation.x += rotationSpeed * 0.2;
        }
      }

      // 新機能の更新
      if (material && material.uniforms) {
        material.uniforms.time.value = time;
        material.uniforms.mousePos.value.set(mouseNormalizedX, mouseNormalizedY);
        material.uniforms.warpMode.value = warpMode ? 1.0 : 0.0;
        material.uniforms.magneticMode.value = magneticMode ? 1.0 : 0.0;
      }

      frameCount++;
      if (frameCount % 60 === 0) {
        const now = performance.now();
        const fps = Math.round(1000 / ((now - lastTime) / 60));
        document.getElementById('fps').textContent = fps;
        lastTime = now;
      }

      renderer.render(scene, camera);
    }

    function toggleAnimation() { isAnimating = !isAnimating; }

    function randomizeColors() {
      if (!geometry) return;
      const colors = geometry.attributes.color.array;
      for (let i = 0; i < particleCount; i++) {
        const color = new THREE.Color();
        const hue = Math.random() * 0.8 + 0.1;
        color.setHSL(hue, 0.8, 0.5 + Math.random() * 0.3);
        colors[i * 3] = color.r;
        colors[i * 3 + 1] = color.g;
        colors[i * 3 + 2] = color.b;
      }
      geometry.attributes.color.needsUpdate = true;
      if (sphereMaterial) {
        const sphereColor = new THREE.Color();
        sphereColor.setHSL(Math.random() * 0.8 + 0.1, 0.8, 0.6);
        sphereMaterial.color = sphereColor;
      }
    }

    function resetView() {
      cameraAngleX = 0;
      cameraAngleY = 0;
      cameraDistance = 12;
      updateCameraPosition();
      warpMode = false;
      magneticMode = false;
      document.getElementById('warpBtn').classList.remove('active');
      document.getElementById('magneticBtn').classList.remove('active');
      document.getElementById('warpBtn').textContent = '🌀 Warp Mode';
      document.getElementById('magneticBtn').textContent = '🧲 Magnetic';
    }

    // 爆発エフェクト（簡略版）
    function explodeSphere() {
      if (isExploding) return;
      isExploding = true;
      explosionStartTime = performance.now();
      explosionProgress = 0;
      createExplosionParticles();
      if (sphereMesh) sphereMesh.visible = false;
      if (particles) particles.visible = false;
      document.getElementById('explodeBtn').disabled = true;
      document.getElementById('explodeBtn').textContent = '💥 爆発中...';
    }

    function createExplosionParticles() {
      explosionParticles.forEach(particle => {
        scene.remove(particle.mesh);
        particle.geometry.dispose();
        particle.material.dispose();
      });
      explosionParticles = [];

      const explosionParticleCount = 500; // 軽量化
      const sphereVertices = sphereGeometry.attributes.position.array;
      const vertexCount = sphereVertices.length / 3;

      for (let i = 0; i < explosionParticleCount; i++) {
        const vertexIndex = Math.floor(Math.random() * vertexCount) * 3;
        const startX = sphereVertices[vertexIndex];
        const startY = sphereVertices[vertexIndex + 1];
        const startZ = sphereVertices[vertexIndex + 2];

        const direction = new THREE.Vector3(startX, startY, startZ).normalize();
        const speed = 0.1 + Math.random() * 0.15;

        const particleGeometry = new THREE.SphereGeometry(0.02 + Math.random() * 0.04, 6, 6);
        const particleMaterial = new THREE.MeshBasicMaterial({
          color: new THREE.Color().setHSL(Math.random() * 0.8 + 0.1, 0.8, 0.6),
          transparent: true,
          opacity: 1
        });

        const particleMesh = new THREE.Mesh(particleGeometry, particleMaterial);
        particleMesh.position.set(startX, startY, startZ);
        scene.add(particleMesh);

        explosionParticles.push({
          mesh: particleMesh,
          geometry: particleGeometry,
          material: particleMaterial,
          velocity: direction.multiplyScalar(speed),
          gravity: -0.002,
          life: 1.0,
          decay: 0.008 + Math.random() * 0.01,
          rotationSpeed: (Math.random() - 0.5) * 0.2
        });
      }
    }

    function updateExplosion() {
      const currentTime = performance.now();
      const elapsedTime = currentTime - explosionStartTime;
      explosionProgress = Math.min(elapsedTime / explosionDuration, 1);

      for (let i = explosionParticles.length - 1; i >= 0; i--) {
        const particle = explosionParticles[i];
        particle.mesh.position.add(particle.velocity);
        particle.velocity.y += particle.gravity;
        particle.mesh.rotation.x += particle.rotationSpeed;
        particle.mesh.rotation.y += particle.rotationSpeed;
        particle.mesh.rotation.z += particle.rotationSpeed;
        particle.life -= particle.decay;
        particle.material.opacity = Math.max(0, particle.life);

        const hue = 0.1 + (1 - particle.life) * 0.1;
        particle.material.color.setHSL(hue, 0.8, 0.5 + particle.life * 0.3);
        const scale = 0.5 + particle.life * 0.5;
        particle.mesh.scale.set(scale, scale, scale);

        if (particle.life <= 0) {
          scene.remove(particle.mesh);
          particle.geometry.dispose();
          particle.material.dispose();
          explosionParticles.splice(i, 1);
        }
      }

      if (explosionProgress >= 1 || explosionParticles.length === 0) {
        endExplosion();
      }
    }

    function endExplosion() {
      isExploding = false;
      explosionParticles.forEach(particle => {
        scene.remove(particle.mesh);
        particle.geometry.dispose();
        particle.material.dispose();
      });
      explosionParticles = [];

      setTimeout(() => {
        if (sphereMesh) sphereMesh.visible = true;
        if (particles) particles.visible = true;
        document.getElementById('explodeBtn').disabled = false;
        document.getElementById('explodeBtn').textContent = '💥 Explode';
      }, 500);
    }

    init();
  </script>
</body>
</html>
