<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>shotomoriyama portfolio</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@100..900&family=Orbitron:wght@400..900&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: radial-gradient(ellipse at center, #1a1a2e 0%, #16213e 50%, #0f0f0f 100%);
      overflow: hidden;
      font-family: "Orbitron", sans-serif;
      height: 100vh;
      cursor: none;
    }

    #container {
      width: 100vw;
      height: 100vh;
      position: relative;
    }

    /* カスタムカーソル */
    #cursor {
      position: fixed;
      width: 25px;
      height: 25px;
      background: radial-gradient(circle, #e6ff28 0%, transparent 70%);
      border-radius: 50%;
      pointer-events: none;
      z-index: 10000;
      mix-blend-mode: screen;
      transition: transform 0.1s ease;
    }

    /* UI オーバーレイ */
    #ui-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1000;
    }

    /* タイトル */
    #main-title {
      position: absolute;
      width: 100%;
      bottom: 5%;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      color: #f9f7f2;
      pointer-events: none;
    }

    #main-title h1 {
      font-size: 9rem;
      font-family: "Orbitron", sans-serif;
      font-weight: 900;
      margin-bottom: 0.5rem;
      text-shadow: 0 0 50px #024550;
      letter-spacing: -15px;
    }

    #main-title p {
      font-size: 1.1rem;
      opacity: 0.8;
      letter-spacing: 1px;
    }

    /* 惑星情報パネル */
    #planet-info {
      position: absolute;
      top: 30px;
      right: 30px;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 15px;
      padding: 20px;
      color: white;
      min-width: 200px;
      opacity: 0;
      transform: translateY(-20px);
      transition: all 0.3s ease;
      pointer-events: all;
    }

    #planet-info.show {
      opacity: 1;
      transform: translateY(0);
    }

    #planet-info h3 {
      margin-bottom: 10px;
      font-size: 1.2rem;
      color: #fff;
    }

    #planet-info p {
      font-size: 0.9rem;
      line-height: 1.5;
      opacity: 0.9;
      margin-bottom: 15px;
    }

    #planet-info .nav-button {
      display: inline-block;
      padding: 8px 16px;
      background: linear-gradient(45deg, #667eea, #764ba2);
      color: white;
      text-decoration: none;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: 600;
      transition: all 0.3s;
      cursor: pointer;
    }

    #planet-info .nav-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
    }

    /* コントロールパネル */
    #controls {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 100;
      background: rgba(1, 1, 197, 0.087);
      backdrop-filter: blue(20px);
      border: 1px solid rgb(236, 236, 236);
      border-radius: 15px;
      padding: 20px;
      color: white;
      pointer-events: all;
      box-shadow: 0 8px 30px rgba(236, 236, 236, 0.378);
    }

    .control-group {
      margin-bottom: 15px;
    }

    .control-group:last-child {
      margin-bottom: 0;
    }

    label {
      display: block;
      font-size: 0.8rem;
      margin-bottom: 5px;
      opacity: 0.9;
    }

    input[type="range"] {
      width: 120px;
      height: 4px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 2px;
      outline: none;
      -webkit-appearance: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 12px;
      height: 12px;
      background: #667eea;
      border-radius: 50%;
      cursor: pointer;
    }

    .value {
      color: #667eea;
      font-weight: bold;
    }

    /* 情報パネル */
    #info {
      position: absolute;
      bottom: 30px;
      left: 30px;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 10px;
      padding: 15px;
      color: white;
      font-size: 0.8rem;
      pointer-events: none;
    }

    /* レスポンシブ */
    @media (max-width: 768px) {
      #main-title h1 {
        font-size: 2rem;
      }

      #controls,
      #planet-info {
        position: relative;
        top: auto;
        left: auto;
        right: auto;
        margin: 20px;
        max-width: calc(100vw - 40px);
      }

      #planet-info {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        max-width: 90vw;
      }
    }
  </style>
</head>
<body>
  <div id="cursor"></div>

  <div id="container">
    <div id="ui-overlay">
      <div id="controls">
        <div class="control-group">
          <label>回転速度: <span class="value" id="speedValue">1.0</span></label>
          <input type="range" id="orbitSpeed" min="0" max="3" value="1" step="0.1">
        </div>
        <div class="control-group">
          <label>軌道サイズ: <span class="value" id="orbitSizeValue">6</span></label>
          <input type="range" id="orbitSize" min="4" max="10" value="6" step="0.5">
        </div>
        <div class="control-group">
          <label>太陽サイズ: <span class="value" id="sunSizeValue">2</span></label>
          <input type="range" id="sunSize" min="1" max="4" value="2" step="0.1">
        </div>
      </div>

      <div id="planet-info">
        <h3 id="planet-name">惑星を選択</h3>
        <p id="planet-description">惑星にホバーして詳細を確認</p>
        <a href="#" class="nav-button" id="planet-link">詳細を見る</a>
      </div>

      <div id="main-title">
        <h1>SHOTO MORIYAMA</h1>
        <p>Navigate through the universe</p>
      </div>

      <div id="info">
        <strong>操作方法:</strong><br>
        マウス移動: 視点変更 | 惑星クリック: ナビゲーション<br>
        FPS: <span class="value" id="fps">60</span>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    let scene, camera, renderer;
    let sun, sunParticles, sunFlares;
    let orbitParticles = [];
    let planets = [];
    let raycaster, mouse;

    // 設定
    let config = {
      orbitSpeed: 1.0,
      orbitRadius: 6,
      sunSize: 2,
      planetCount: 4
    };

    // 惑星データ
    const planetData = [
      {
        name: "About",
        description: "私について、経歴、スキルセットなどをご紹介します",
        color: 0xff6b6b,
        size: 0.3,
        link: "#about"
      },
      {
        name: "Projects",
        description: "これまでに手がけたプロジェクトと実績をご覧ください",
        color: 0x4ecdc4,
        size: 0.4,
        link: "#projects"
      },
      {
        name: "Skills",
        description: "技術スタック、ツール、専門分野について詳しく説明します",
        color: 0x45b7d1,
        size: 0.35,
        link: "#skills"
      },
      {
        name: "Contact",
        description: "お仕事のご依頼、ご相談はこちらからお気軽にどうぞ",
        color: 0x96ceb4,
        size: 0.25,
        link: "#contact"
      }
    ];

    // マウス制御
    let mouseX = 0, mouseY = 0;
    let targetCameraX = 0, targetCameraY = 0;

    // アニメーション
    let time = 0;
    let frameCount = 0;
    let lastTime = performance.now();

    // 選択された惑星
    let selectedPlanet = null;
    let hoveredPlanet = null;

    function init() {
      // シーン作成
      scene = new THREE.Scene();

      // カメラ作成
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 0, 12);

      // レンダラー作成
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x000000, 1);
      document.getElementById('container').appendChild(renderer.domElement);

      // レイキャスター
      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();

      // ライティング
      setupLighting();

      // 太陽作成
      createSun();

      // 軌道作成
      createOrbitRings();

      // 惑星作成
      createPlanets();

      // イベントリスナー
      setupEventListeners();

      // アニメーション開始
      animate();
    }

    function setupLighting() {
      // 環境光
      const ambientLight = new THREE.AmbientLight(0x404040, 0.2);
      scene.add(ambientLight);

      // 太陽光（メインライト）
      const sunLight = new THREE.PointLight(0xffa500, 2.0, 100);
      sunLight.position.set(0, 0, 0);
      scene.add(sunLight);

      // 補助光
      const fillLight = new THREE.PointLight(0xff6b35, 0.5, 50);
      fillLight.position.set(0, 0, 0);
      scene.add(fillLight);
    }

    function createSun() {
      // 太陽ジオメトリ
      const sunGeometry = new THREE.SphereGeometry(config.sunSize, 64, 64);

      // 太陽マテリアル（炎のような動的エフェクト）
      const sunMaterial = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          color1: { value: new THREE.Color(0xff4500) }, // オレンジレッド
          color2: { value: new THREE.Color(0xffa500) }, // オレンジ
          color3: { value: new THREE.Color(0xffff00) }  // イエロー
        },
        vertexShader: `
            varying vec3 vPosition;
            varying vec3 vNormal;
            varying vec2 vUv;
            uniform float time;

            // ノイズ関数
            float noise(vec3 pos) {
              return sin(pos.x * 2.0) * sin(pos.y * 3.0) * sin(pos.z * 5.0);
            }

            void main() {
              vPosition = position;
              vNormal = normal;
              vUv = uv;

              vec3 pos = position;

              // 炎のような動的な変形
              float n1 = noise(position + time * 2.0) * 0.1;
              float n2 = noise(position * 2.0 + time * 1.5) * 0.05;
              float n3 = noise(position * 4.0 + time * 3.0) * 0.02;

              pos += normal * (n1 + n2 + n3);

              gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
          `,
        fragmentShader: `
            uniform float time;
            uniform vec3 color1;
            uniform vec3 color2;
            uniform vec3 color3;
            varying vec3 vPosition;
            varying vec3 vNormal;
            varying vec2 vUv;

            // ノイズ関数
            float noise(vec2 pos) {
              return sin(pos.x * 10.0 + time) * sin(pos.y * 10.0 + time * 1.3);
            }

            void main() {
              vec3 viewDirection = normalize(cameraPosition - vPosition);
              float fresnel = pow(1.0 - dot(vNormal, viewDirection), 1.5);

              // 炎のような色彩変化
              float n1 = noise(vUv * 5.0 + time * 2.0) * 0.5 + 0.5;
              float n2 = noise(vUv * 8.0 + time * 1.8) * 0.5 + 0.5;
              float n3 = noise(vUv * 12.0 + time * 2.5) * 0.5 + 0.5;

              vec3 color = mix(color1, color2, n1);
              color = mix(color, color3, n2 * 0.7);

              // 表面の輝き
              color += vec3(1.0, 0.8, 0.3) * n3 * 0.3;

              // フレネル効果で輪郭を明るく
              color += vec3(1.0, 0.9, 0.5) * fresnel * 0.8;

              gl_FragColor = vec4(color, 1.0);
            }
          `,
        transparent: false
      });

      sun = new THREE.Mesh(sunGeometry, sunMaterial);
      scene.add(sun);

      // 太陽周りの粒子（フレア効果）
      createSunParticles();

      // 太陽のコロナ効果
      createSunFlares();
    }
    function createSunParticles() {
        const particleCount = 1000;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const sizes = new Float32Array(particleCount);

        for (let i = 0; i < particleCount; i++) {
          const radius = config.sunSize + 0.3 + Math.random() * 2.0;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(Math.random() * 2 - 1);

          positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
          positions[i * 3 + 1] = radius * Math.cos(phi);
          positions[i * 3 + 2] = radius * Math.sin(phi) * Math.sin(theta);

          // 太陽らしい色合い（オレンジ〜赤〜黄色）
          const color = new THREE.Color();
          const hue = 0.05 + Math.random() * 0.1; // オレンジから黄色の範囲
          color.setHSL(hue, 0.9, 0.6 + Math.random() * 0.4);
          colors[i * 3] = color.r;
          colors[i * 3 + 1] = color.g;
          colors[i * 3 + 2] = color.b;

          sizes[i] = 0.05 + Math.random() * 0.1;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

        const material = new THREE.ShaderMaterial({
          uniforms: {
            time: { value: 0 }
          },
          vertexShader: `
          attribute float size;
          attribute vec3 color;
          varying vec3 vColor;
          uniform float time;

          void main() {
            vColor = color;
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);

            // 炎のような揺らぎ
            mvPosition.xyz += sin(time * 3.0 + position.x * 0.1) * 0.02;
            mvPosition.xyz += cos(time * 2.5 + position.y * 0.1) * 0.02;

            gl_PointSize = size * (300.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
          }
        `,
          fragmentShader: `
          varying vec3 vColor;

          void main() {
            vec2 center = gl_PointCoord - 0.5;
            float r = length(center);
            if (r > 0.5) discard;
            float alpha = 1.0 - smoothstep(0.0, 0.5, r);
            gl_FragColor = vec4(vColor, alpha * 0.9);
          }
        `,
          transparent: true,
          blending: THREE.AdditiveBlending,
          depthTest: false
        });

        sunParticles = new THREE.Points(geometry, material);
        scene.add(sunParticles);
      }

      function createSunFlares() {
        // 太陽のコロナ（光輪）
        const flareGeometry = new THREE.SphereGeometry(config.sunSize * 1.8, 32, 32);
        const flareMaterial = new THREE.ShaderMaterial({
          uniforms: {
            time: { value: 0 }
          },
          vertexShader: `
          varying vec3 vPosition;
          varying vec3 vNormal;
          uniform float time;

          void main() {
            vPosition = position;
            vNormal = normal;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
          fragmentShader: `
          uniform float time;
          varying vec3 vPosition;
          varying vec3 vNormal;

          void main() {
            vec3 viewDirection = normalize(cameraPosition - vPosition);
            float fresnel = pow(1.0 - dot(vNormal, viewDirection), 2.0);

            // 動的な光の強度
            float intensity = sin(time * 2.0 + vPosition.x) * 0.3 + 0.7;

            vec3 coronaColor = vec3(1.0, 0.7, 0.3) * fresnel * intensity;

            gl_FragColor = vec4(coronaColor, fresnel * 0.4);
          }
        `,
          transparent: true,
          blending: THREE.AdditiveBlending,
          side: THREE.BackSide
        });

        sunFlares = new THREE.Mesh(flareGeometry, flareMaterial);
        scene.add(sunFlares);
      }

      function createOrbitRings() {
        const ringCount = 3;

        for (let ring = 0; ring < ringCount; ring++) {
          const particleCount = 100 + ring * 50;
          const radius = config.orbitRadius + ring * 1.5;
          const geometry = new THREE.BufferGeometry();
          const positions = new Float32Array(particleCount * 3);
          const colors = new Float32Array(particleCount * 3);

          for (let i = 0; i < particleCount; i++) {
            const angle = (i / particleCount) * Math.PI * 2;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            const y = (Math.random() - 0.5) * 0.2;

            positions[i * 3] = x;
            positions[i * 3 + 1] = y;
            positions[i * 3 + 2] = z;

            colors[i * 3] = 1;
            colors[i * 3 + 1] = 1;
            colors[i * 3 + 2] = 1;
          }

          geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
          geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

          const material = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.01,
            transparent: true,
            opacity: 0.3 - ring * 0.05,
            blending: THREE.AdditiveBlending
          });

          const orbitRing = new THREE.Points(geometry, material);
          orbitParticles.push(orbitRing);
          scene.add(orbitRing);
        }
      }

      function createPlanets() {
        planets = [];

        for (let i = 0; i < config.planetCount; i++) {
          const data = planetData[i];
          const angle = (i / config.planetCount) * Math.PI * 2;

          // 惑星ジオメトリ
          const planetGeometry = new THREE.SphereGeometry(data.size, 32, 32);
          const planetMaterial = new THREE.MeshPhongMaterial({
            color: data.color,
            shininess: 100,
            transparent: true,
            opacity: 0.9
          });

          const planet = new THREE.Mesh(planetGeometry, planetMaterial);

          // 初期位置設定
          planet.position.x = Math.cos(angle) * config.orbitRadius;
          planet.position.z = Math.sin(angle) * config.orbitRadius;
          planet.position.y = 0;

          // データ保存
          planet.userData = {
            ...data,
            angle: angle,
            baseRadius: config.orbitRadius,
            originalScale: planet.scale.x
          };

          planets.push(planet);
          scene.add(planet);

 // 惑星の光輪
 const glowGeometry = new THREE.SphereGeometry(data.size * 1.5, 16, 16);
        const glowMaterial = new THREE.MeshBasicMaterial({
          color: data.color,
          transparent: true,
          opacity: 0.2,
          side: THREE.BackSide
        });

        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        planet.add(glow);
      }
    }

    function setupEventListeners() {
      window.addEventListener('resize', onWindowResize);

      // マウス移動
      document.addEventListener('mousemove', (e) => {
        mouseX = (e.clientX / window.innerWidth) * 2 - 1;
        mouseY = -(e.clientY / window.innerHeight) * 2 + 1;

        targetCameraX = mouseX * 2;
        targetCameraY = mouseY * 2;

        // カーソル更新
        document.getElementById('cursor').style.left = e.clientX - 6 + 'px';
        document.getElementById('cursor').style.top = e.clientY - 6 + 'px';

        // レイキャスティング
        mouse.x = mouseX;
        mouse.y = mouseY;
        checkIntersections();
      });

      // クリックイベント
      document.addEventListener('click', onPlanetClick);

      // コントロール
      document.getElementById('orbitSpeed').addEventListener('input', (e) => {
        config.orbitSpeed = parseFloat(e.target.value);
        document.getElementById('speedValue').textContent = config.orbitSpeed.toFixed(1);
      });

      document.getElementById('orbitSize').addEventListener('input', (e) => {
        config.orbitRadius = parseFloat(e.target.value);
        document.getElementById('orbitSizeValue').textContent = config.orbitRadius;
        updateOrbitPositions();
      });

      document.getElementById('sunSize').addEventListener('input', (e) => {
        config.sunSize = parseFloat(e.target.value);
        document.getElementById('sunSizeValue').textContent = config.sunSize;
        if (sun) {
          sun.scale.setScalar(config.sunSize / 2);
        }
        if (sunFlares) {
          sunFlares.scale.setScalar(config.sunSize / 2);
        }
      });
    }

    function checkIntersections() {
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(planets);

      // すべての惑星をリセット
      planets.forEach(planet => {
        planet.scale.setScalar(planet.userData.originalScale);
        planet.material.emissive.setHex(0x000000);
      });

      if (intersects.length > 0) {
        const planet = intersects[0].object;
        hoveredPlanet = planet;

        // ホバーエフェクト
        planet.scale.setScalar(planet.userData.originalScale * 1.3);
        planet.material.emissive.setHex(0x333333);

        // 情報パネル更新
        showPlanetInfo(planet.userData);
      } else {
        hoveredPlanet = null;
        hidePlanetInfo();
      }
    }

    function showPlanetInfo(data) {
      const infoPanel = document.getElementById('planet-info');
      document.getElementById('planet-name').textContent = data.name;
      document.getElementById('planet-description').textContent = data.description;
      document.getElementById('planet-link').href = data.link;
      infoPanel.classList.add('show');
    }

    function hidePlanetInfo() {
      document.getElementById('planet-info').classList.remove('show');
    }

    function onPlanetClick() {
      if (hoveredPlanet) {
        const data = hoveredPlanet.userData;
        console.log(`Navigating to: ${data.name} (${data.link})`);
        // ここで実際のページ遷移や処理を実装
      }
    }

    function updateOrbitPositions() {
      planets.forEach((planet, index) => {
        planet.userData.baseRadius = config.orbitRadius;
      });
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);

      time += 0.016;

      // カメラのスムーズな移動
      camera.position.x += (targetCameraX - camera.position.x) * 0.05;
      camera.position.y += (targetCameraY - camera.position.y) * 0.05;
      camera.lookAt(0, 0, 0);

      // 太陽の回転とアニメーション
      if (sun) {
        sun.rotation.y += 0.01;
        sun.material.uniforms.time.value = time;
      }

      // 太陽粒子の回転
      if (sunParticles) {
        sunParticles.rotation.y += 0.005;
        sunParticles.material.uniforms.time.value = time;
      }

      // 太陽フレアのアニメーション
      if (sunFlares) {
        sunFlares.rotation.y -= 0.003;
        sunFlares.material.uniforms.time.value = time;
      }

      // 軌道リングの回転
      orbitParticles.forEach((ring, index) => {
        ring.rotation.y += 0.001 * (index + 1);
      });

      // 惑星の公転
      planets.forEach((planet, index) => {
        const data = planet.userData;
        data.angle += 0.01 * config.orbitSpeed * (1 + index * 0.1);

        planet.position.x = Math.cos(data.angle) * data.baseRadius;
        planet.position.z = Math.sin(data.angle) * data.baseRadius;

        // 惑星の自転
        planet.rotation.y += 0.02;
      });

      // FPS計算
      frameCount++;
      if (frameCount % 60 === 0) {
        const now = performance.now();
        const fps = Math.round(1000 / ((now - lastTime) / 60));
        document.getElementById('fps').textContent = fps;
        lastTime = now;
      }

      renderer.render(scene, camera);
    }

    // 初期化実行
    init();
  </script>
</body>
</html>
